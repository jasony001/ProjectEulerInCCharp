using System;
using System.Collections.Generic;
using System.Linq;
using ProjectEulerDataContracts;

namespace ProjectEulerLib
{
    public class Problem12Solver : ProblemSolver
    {

        List<List<string>> sourceCodeLinesList = new List<List<string>>{
            new List<string> {

            },
            new List<string>{

            }
        };

        public Problem12Solver() : base()
        {
            Problem.Id = 12;
            Problem.UpperBound = 500;
            Problem.IsClosedOnRight = true;
            Problem.Title = "Highly divisible triangular number";
            Problem.Description =
                "The sequence of triangle numbers is generated by adding the natural numbers. So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:\n"
                + "1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...\n"
                + "Let us list the factors of the first seven triangle numbers\n"
                + "     1: 1\n"
                + "     3: 1,3\n"
                + "     6: 1,2,3,6\n"
                + "    10: 1,2,5,10\n"
                + "    15: 1,3,5,15\n"
                + "    21: 1,3,7,21\n"
                + "    28: 1,2,4,7,14,28\n"
                + "We can see that 28 is the first triangle number to have over five divisors.\n"
                + "What is the value of the first triangle number to have over five hundred divisors?";

            Problem.Solutions.Add(new Solution
            {
                ProblemId = 12,
                Description = "17,000 milliseconds! Get count factors of a number: get map of prime factors, for example 360: {{2,3}, {3, 2}, {5, 1}}. Count all the combinations.",
                Version = 1,
                SolutionCodes = ConvertStringListToSolutionCodeList(sourceCodeLinesList[0])
            });
            // Problem.Solutions.Add(new Solution
            // {
            //     ProblemId = 2,
            //     Description = "Flatten the grid, build rowLists, columnLists, ForwardDiagonalLists, backDiagonalLists. Then loop to find the max product of 4.",
            //     Version = 2,
            //     SolutionCodes = ConvertStringListToSolutionCodeList(sourceCodeLinesList[1])
            // });
        }
        
        long CalculatedPrimeUpperBound = 6;
        
        long[] CalculatedPrimes = new long[] {2, 3};

        List<long> GetListsOfNumberOfPrimeFactors(long n)
        {
            if (n > CalculatedPrimeUpperBound)
            {
                CalculatedPrimeUpperBound += 2000000;
                CalculatedPrimes = new MoreMath.PrimeCalculator().SeiveOfEratosthenes(CalculatedPrimes, CalculatedPrimeUpperBound);
            }

            long parm = n;
            long sqrtOfN = (long)(Math.Sqrt(n));
            List<long> result = new List<long>();

            foreach(long p in CalculatedPrimes)
            {
                int count = 0;
                while(n % p == 0)
                {
                    count ++;
                    n /= p;
                }
                if (count > 0) result.Add(count);
            }

            if (n > sqrtOfN && n < parm) result.Add(1);

            return result;
        }

        public override string solution1()
        {
            long x = 20;
            long n = 210;
            MoreMath.FactorCalculator worker = new MoreMath.FactorCalculator();
            long numberOfFactors = 0;
            while (numberOfFactors <= Problem.CalculatedIncludedUpperBound && x < 1000000)
            {
                n = x * (x + 1) / 2;
                numberOfFactors = worker.GetNumberOfFactors(n);

                Console.WriteLine($"x={x} n={n}: {numberOfFactors} factors");
                x ++;
            }

            return (numberOfFactors > Problem.CalculatedIncludedUpperBound) ? n.ToString() : "No solution for any x(x+1)/2 when x < 1000000";
        }



        public override string solution2()
        {
            return "";
        }
    }
}
